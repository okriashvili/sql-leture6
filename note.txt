VIEW:
-- views - ვიუები არის ერთგვარი ვირტუალური გარემო სადაც ვინახავთ sql ბრძანებებს/მოთხოვნებს, 
-- იმისათვის რომ იგივე ბრძანებები არ ვწეროთ ბევრჯერ, შეგვიძლია viewsში შევინქხოთ და იქიდან წამოვიღოთ
-- views ში არ ინახება უშუალოდ ბრძანება/მოთხოვნა არამედ ინფორმაცია რომელიც ჩვენს მიერ გადაცემულს ბრძანებას მოაქ 

-- views არის ვურტუალური ცხრილი, რომელიც არ შეიცავს მონაცემებს, არამედ ჩვენი მოთხოვნის შედეგს შეიცავს, 
-- ანუ რა მონაცემებსაც ჩვენი მოთხოვნა აბრუნებს, ამ მონაცემებს შეიცავს იგი
-- მაგ: როდესაც მოთხოვნა დავწერეთ, როდესაც დავხურავთ sql ადმინს, ჩვენს მიერ დაწერილი მოთხოვნა დაიკარგება, 
-- ან როდესაც გვსურს ერთ მოთხოვნას ხშირად ვიყენებთ, უმჯობესია რომ შევინახოთ ეს მოთხოვნა viewsში, და შემდგომ view გამოვიყენოთ

-- 1: კოდის გამარტივება
-- viewsს ამარტივებს მოთხოვნებს რათა ერთი და იმავე მოთხვნის ხშირად დაწერა არ მოგვიწიოს

-- 2: უსაფრთხოება: 
-- შეგვიძლია crud ოპერაციებზე შევზღუდოთ იუზერი, ჯგუფები
-- დეფაულტან public სქემებზე ოთხივე ოპერციების შესრულება შეგვიძლია />>> 
-- მაგრამ viewsზე შეგვიძლია შევზღუდოთ და მხოლოდ წაშლის ან სხვა ოპერაციების შესრულების უფლება მივცეთ 

-- ეფექტურობა:
-- მაგ: ინფორმაცის წამოღებისას მოთხოვნა ეშვება ბაზაში, ბევრი ინფორმაციის წამოღებისას შესაძლოა ეფექტურობა დაკარგოს და >>> 
-- views გვაძლევს საშუალოებას რომ ეფექტურობა არ დაკარგოს ბაზამ ერთდროულად ბევრი მონაცემის გაშვებისას  

-- მონაცემთა დამოუკიდებლობა:
-- როდესაც მონაცემები მოგვაქვს, თუკი ცხრილში რაიმე მონაცემი შევცვალეთ, viewsშიც ავტომატურად შეიცვლება მონაცემი
-- მუდმივ კავშირშია ცხრილებთან, viewsში აღარ მოგვიწევს თავიდან განახლება, არამედ ავტომატურად წამოიღებს განახლებულ მონაცემს

-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- viewsის შესაქმენელად ვიყენებთ შემდეგ სინტაქსს:
-- 1: create ბრძანება
-- 2: views საკვანძო სიტყვა
-- 3: views სახელი უნდა დავარქვათ
-- 4: as ბრძანება და
	-- create view all_data as select name, salary, department_name, location from employees e
	-- join departments d on d.department_id = e.department_id
-- შევქმენით view რომელსაც დავარქვით all_data, შიგნით კი შევინახეთ დაჯოინბული ცხრილების ინფორმაცია
-- შეგვიძლია ის ინფორმაცია წამოვიღოთ რომლის viewში შეტანაც გვინდა


-- შეგვიძლია მოთხოვნები viewზეც გავწეროთ, გავილტროთ რაღაცის მიხედვით და ა შ.
	-- select * from all_data where name ilike('%a%')
-- ან აგრეგირების ფუნქცია შევასრულოთ
	-- select avg(salary) from all_data 
-- აგრეგირების ფუქნცია და გაფილტვრს ერთად გამოვიყენოთ
	-- select sum(salary) from all_data where department_name = 'Marketing' 



-- viewს მოდიფიკაცია, შეცვლა ან ჩამატება
-- ისეთივე სინტაქსი აქვს როგორც შექმნას მაგრამ create or replaceს ვიყნებთ
-- -- მოდიფიკაციით შეგვიძლია სვეტის ჩამატება 
	-- 	create or replace view all_data as select name, salary, department_name, location, e.department_id from employees e		
	-- 	join departments d on d.department_id = e.department_id
	-- select * from all_data

-- მაგრამ არ შეგვიძლია სვეტის ამოშლა 
	-- create or replace view all_data as select name, salary, department_name from employees e		
	-- join departments d on d.department_id = e.department_id
	-- select * from all_data
-- სვეტის წასაშლელად მთლიანი view უნდა წავშალოთ და ახლუდან შევქმნათ


-- viewს წასაშლელად კი საჭიროა drop view ბრძანება
-- drop view all_data






Stored_procedures:
-- შენახული პროცედურები / stored procedures
-- სერვერზე შენნახული და შესრულებადი კოდის ბლოკი, რომელიც სამომავლოდ შეგვიძლია გამოვიყენოთ
-- მაგრამ, შენახული პროცედურა არ აბრუნებს არაფერს, არც მონაცემებს. პროცედურის დროს ხდება უშუალოდ ოპერაციის განხორციელება
-- უპირატესობა ისაა რომ ხშირად არ გვიწევს იგივე მოთხოვ ნების დაწერა

-- პროცედურის შექმნის სინტაქსი:
-- 1: create prodecures ბრძანება
-- 2: პროცედურის დასახელება() ფრჩხილებში შეგვიძლია არგუმენტები გადავცეთ
-- 3: language plpgsql AS
-- language plpgsql არის ენა, რომლითაც ვწერთ ამ კოდს
-- 4: $$ begin - 
-- დოლარის ნიშნებშ ვწერთ begin და end საკვანძო სიტყვებს რომლებშიც უშუალოდ ვწერთ ჩვენს ბრძანებას/მოთხოვნას
-- 5: end $$

-- create procedure increase_salary() 
-- language plpgsql AS
-- $$ 
-- BEGIN
-- 	update employees set salary = salary * 1.1 WHERE salary < 50000;
-- END
-- $$

-- პროცედურის ასამოქმედებლად კი საჭიროა გამოვიძახოთ call ბრძანებით
-- call increase_salary()
-- შეგვიძლია ფილტრაცია გავუკეთოთ და ამ მონაცემებზე გამოვიძახოთ პროცედურა



-- როგორცც ვიცით პროცედურას შეგვიძია გადავცეთ არგუმენტებიც:
-- თუკი დასაქმებულს არ აქვს მინიჭებული დეპარტამენტი, 
-- ეს პროცედურა მიანიჭებს მას იმ დეპარტამენტს რომლის აიდისაც გადავცემთ პროცედურის გამოძახებისას
-- create procedure assign_department(emp_id INT)
-- language plpgsql AS
-- $$
-- BEGIN
-- 	update employees set department_id = emp_id where employees.department_id is null;
-- END
-- $$
-- call assign_department(2)


-- create procedure set_salary(emp_id INT)
-- language plpgsql AS
-- $$
-- BEGIN
-- 	update employees set salary = 35000 where employee_id = emp_id;
-- END
-- $$
-- drop procedure set_salary
-- call set_salary(4)

-- create procedure inc_salary(amount INT, emp_id INT)
-- language plpgsql AS
-- $$
-- BEGIN
-- 	update employees set salary = salary + amount where employee_id = emp_id;
-- END
-- $$
-- call inc_salary(10000, 4)


-- drop procedure 









-- triggers/ტრიგერები:
-- triggers/ტრიგერები:
-- ავტომატური მექანიზმი რომელიც ავტომატურად იძახებს ფუნქციას, მონაცემის შეცვლის/წაშლის/დამატების დროს
-- შეგვიძლია ავტომატურად მივუთითოთ როდის და რა დროს გაეშვას ფუქნციას,
-- მაგ: მონაცემის შენახვისას/წაშლის/დამატების დროს და ან ოპერაციის დაწყების თუ დამთავრების შემდეგ დროს.
-- triggerის შექმნის სინტაქსი / სანამ შევქმნით ტრიგერს უნდა შევქმნათ ფინქცია და ეს ფუქნცია უნდა აღვასრულებინოთ ტრიგერს

-- ფუნქციას ვქმნით ისევე როგორც პროცედურას და 
-- ისეთივე სინტაქსი აქვს როგორ პროცედურის შექმნას, მაგრამ პროცედურისგან განსხვავებით ტრიგერი აბრუნებს 
-- create or replace function check_status()
-- -- create ბრანების შემდეგ უნდა დავუწეროთ return trigger ბრძანება
-- returns trigger
-- language plpgsql AS
-- $$
-- BEGIN
-- როდესაც ფუნქციას ვქმნით და მონაცემი/ობიექტი განახლდება, ფუქნცია ამას აღიქვანს როგორც new 
-- ამიტომ სინქტასია შემდეგი. იმ სვეტს რომელსაც ვცვლით და ვიყენებთ ფუნქციაში უნდა დავუწეროთ წინ new. საკვანძო სიტყვა
-- -- დავახარისხოთ დასაქმებულები ხელფასის მიხედვით
-- 	if new.salary > 60000 then
-- ფუნქციაში, ოპერაციის გაწერის შემდეგ მაგ: როგორც გვიწერია რომ თუკი salary არის 60000მეტი, უნდა დავუწეროთ then საკვანძო სიტყვა რაც გულისხმობს რომ >>>
-- თუკი salary არის 60000მეტი, მაშინ(then) გააკეთე ის რასაც შემდეგ დავუწეროთ
-- 	new.status := 'high salary';
-- 	elseif new.salary between 50000 and 60000 then
-- 	new.status := 'normal';
-- 	else
-- 	new.status := 'base';
-- ბოლოს კი უნდა გავუწეროთ: end if - აღნიშნავს იმას თუკი სად უნდა დამთავრდეს და >>;
-- 	end if;
-- დამთავრების შემდეგ კი უნდა დააბრუნოს new ობიექტი
-- 	return new;
-- END
-- $$
-- მას შემდეგ რაც შევქმენით ფუნქცია უნდა შევქმნათ ტრიგერი რომელიც აღასრულლებს ამ ფუნქციას ავტოომატურად
-- trigger syntax:
		-- CREATE TRIGGER update_status--create trigger ის შემდეგ ტრიგერუს სახელი 
-- before ან after(ერთ-ერთი ბრძანება) - update or innsert ის გაკეთებამდე თუ გაკეთების შემდეგ გაეშვას ტრიგერი 
-- ანუ ცხრილში მონაცემის შეყვანა/შეცვლამდე თუ შემდეგ უნდა გაეშვას ტრიგერი
-- on-ს უნდა დავუწეროთ ცხრილის სახელი რომელ ცხრილზეც უნდა გაკეთდეს ტრიგერი
-- on ით მივუთითებთ იმას თუკი რომელ ცხრილზეც უნდა ავამუშავოთ ტრიგერი
		-- before update or insert on employees
-- ცხრილზე დაკავშირების შემდეგ უნდა გავუწეროთ რომ ყველა რიგზე უნდა აღასრულოს ფუნქცია 
		-- for each row 
-- ბოლოს კი ბრძანება რომ ფუნქცია აღესრულოს და ფუნქციის დასახელება რომელიც უნდა გაეშვას
		-- execute function check_status()
-- შექმნილი ტრიგერის ნახვა შეგვიძლია tableში იმ ცხრილშ რომელშიც შევქმენით
		-- CREATE TRIGGER update_status
		-- before update or insert on employees
		-- for each row
		-- execute function check_status()


--  მას შემდეგ რაც დაავააფდეიდებთ ნებისმიერ მონაცემს ტრიგერი ავტომატურად გაეშვება ამ მონაცემის-ს statusზე და შეიცვლება 
update employees set department_id = 7 where employee_id = 11
-- მას შემდეგ რაც employeeს შევუცვალეთ დეპარტამენტი, statusიც ავტომატურად შეიცვალა normalზე, რადგანაც მისი ხელფასი იყო 50 da 60 ათასს შორის 